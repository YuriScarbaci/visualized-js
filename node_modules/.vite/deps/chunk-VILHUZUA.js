import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/.pnpm/refractor@2.10.1/node_modules/refractor/lang/pug.js
var require_pug = __commonJS({
  "node_modules/.pnpm/refractor@2.10.1/node_modules/refractor/lang/pug.js"(exports, module) {
    module.exports = pug;
    pug.displayName = "pug";
    pug.aliases = [];
    function pug(Prism) {
      ;
      (function(Prism2) {
        Prism2.languages.pug = {
          comment: {
            pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ]+.+)*/m,
            lookbehind: true
          },
          "multiline-script": {
            pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
            lookbehind: true,
            inside: {
              rest: Prism2.languages.javascript
            }
          },
          filter: {
            pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
            lookbehind: true,
            inside: {
              "filter-name": {
                pattern: /^:[\w-]+/,
                alias: "variable"
              }
            }
          },
          "multiline-plain-text": {
            pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
            lookbehind: true
          },
          markup: {
            pattern: /(^[\t ]*)<.+/m,
            lookbehind: true,
            inside: {
              rest: Prism2.languages.markup
            }
          },
          doctype: {
            pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
            lookbehind: true
          },
          "flow-control": {
            pattern: /(^[\t ]*)(?:if|unless|else|case|when|default|each|while)\b(?: .+)?/m,
            lookbehind: true,
            inside: {
              each: {
                pattern: /^each .+? in\b/,
                inside: {
                  keyword: /\b(?:each|in)\b/,
                  punctuation: /,/
                }
              },
              branch: {
                pattern: /^(?:if|unless|else|case|when|default|while)\b/,
                alias: "keyword"
              },
              rest: Prism2.languages.javascript
            }
          },
          keyword: {
            pattern: /(^[\t ]*)(?:block|extends|include|append|prepend)\b.+/m,
            lookbehind: true
          },
          mixin: [
            {
              pattern: /(^[\t ]*)mixin .+/m,
              lookbehind: true,
              inside: {
                keyword: /^mixin/,
                function: /\w+(?=\s*\(|\s*$)/,
                punctuation: /[(),.]/
              }
            },
            {
              pattern: /(^[\t ]*)\+.+/m,
              lookbehind: true,
              inside: {
                name: {
                  pattern: /^\+\w+/,
                  alias: "function"
                },
                rest: Prism2.languages.javascript
              }
            }
          ],
          script: {
            pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]+).+/m,
            lookbehind: true,
            inside: {
              rest: Prism2.languages.javascript
            }
          },
          "plain-text": {
            pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]+).+/m,
            lookbehind: true
          },
          tag: {
            pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
            lookbehind: true,
            inside: {
              attributes: [
                {
                  pattern: /&[^(]+\([^)]+\)/,
                  inside: {
                    rest: Prism2.languages.javascript
                  }
                },
                {
                  pattern: /\([^)]+\)/,
                  inside: {
                    "attr-value": {
                      pattern: /(=\s*)(?:\{[^}]*\}|[^,)\r\n]+)/,
                      lookbehind: true,
                      inside: {
                        rest: Prism2.languages.javascript
                      }
                    },
                    "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                    punctuation: /[!=(),]+/
                  }
                }
              ],
              punctuation: /:/
            }
          },
          code: [
            {
              pattern: /(^[\t ]*(?:-|!?=)).+/m,
              lookbehind: true,
              inside: {
                rest: Prism2.languages.javascript
              }
            }
          ],
          punctuation: /[.\-!=|]+/
        };
        var filter_pattern = /(^([\t ]*)):{{filter_name}}(?:(?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/.source;
        var filters = [
          {
            filter: "atpl",
            language: "twig"
          },
          {
            filter: "coffee",
            language: "coffeescript"
          },
          "ejs",
          "handlebars",
          "less",
          "livescript",
          "markdown",
          {
            filter: "sass",
            language: "scss"
          },
          "stylus"
        ];
        var all_filters = {};
        for (var i = 0, l = filters.length; i < l; i++) {
          var filter = filters[i];
          filter = typeof filter === "string" ? {
            filter,
            language: filter
          } : filter;
          if (Prism2.languages[filter.language]) {
            all_filters["filter-" + filter.filter] = {
              pattern: RegExp(
                filter_pattern.replace("{{filter_name}}", filter.filter),
                "m"
              ),
              lookbehind: true,
              inside: {
                "filter-name": {
                  pattern: /^:[\w-]+/,
                  alias: "variable"
                },
                rest: Prism2.languages[filter.language]
              }
            };
          }
        }
        Prism2.languages.insertBefore("pug", "filter", all_filters);
      })(Prism);
    }
  }
});

export {
  require_pug
};
//# sourceMappingURL=chunk-VILHUZUA.js.map
